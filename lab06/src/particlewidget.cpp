#include "particlewidget.h"
#include "common.h"
#include "particleemitter.h"
#include "CS123Common.h"

#ifdef __APPLE__
#include <OpenGL/glu.h>
#else
#include <GL/glu.h>
#endif

#include "gl.h"
#include "OpenGL.h"
#include <QMouseEvent>
#include <QTimer>
#include <QGLShader>
#include <QGLShaderProgram>
#include <QFile>


ParticleWidget::ParticleWidget(QWidget *parent) : QGLWidget(QGLFormat(QGL::SampleBuffers | QGL::DoubleBuffer), parent)
{
    m_camera = new Camera();
    m_camera->eye.x = 0.0f, m_camera->eye.y = 0.0f, m_camera->eye.z = 50.0f;
    m_camera->center.x = 0.0f, m_camera->center.y = 0.0f, m_camera->center.z = 0.0f;
    m_camera->up.x = 0.0f, m_camera->up.y = 1.0f, m_camera->up.z = 0.0f;
    m_camera->angle = 45.0f, m_camera->near = .1f, m_camera->far = 1000.0f;

    m_quadric = gluNewQuadric();

    //Do not change below here
    setAutoBufferSwap(false);
    setFocusPolicy(Qt::StrongFocus);
    m_timer = new QTimer(this);
    m_increment = 0.0;
    connect(m_timer, SIGNAL(timeout()), this, SLOT(redraw()));
    m_timer->start(1000.0f / 20.0f);

    m_emitters = new Emitter*[NUM_EMITTERS];
    double width_inc = ((double) FTN_WIDTH) / ((double) NUM_EMITTERS);
    double x_pos = 0.0;

    for (int i = 0; i < NUM_EMITTERS; i++)
    {
        Emitter *e = new Emitter(x_pos, FTN_HEIGHT, m_quadric);
        m_emitters[i] = e;
        x_pos += width_inc;
    }
}

ParticleWidget::~ParticleWidget()
{
    safeDelete(m_timer);
    safeDelete(m_camera);
    //safeDelete(m_emitter);
    safeDeleteArray(m_emitters);
    gluDeleteQuadric(m_quadric);
    makeCurrent();
}

/**
  * You need to fill this in.
  *
  * Loads the image at the given path and copies its data into an OpenGL texture.
  * @return The unique ID of the texture generated by this function.
  */
GLuint ParticleWidget::loadTexture(const QString &path)
{
    QFile file(path);

    QImage image, texture;
    if(!file.exists()) return -1;
    image.load(file.fileName());
    texture = QGLWidget::convertToGLFormat(image);

    //Put your code here
    GLuint tex_id;
    glGenTextures(1, &tex_id);

    glBindTexture(GL_TEXTURE_2D, tex_id);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, image.width(), image.height(),
                 0, GL_RGBA, GL_UNSIGNED_BYTE, image.bits());

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    
    return tex_id; /* return something meaningful */
}

/**
  * You need to fill this in.
  *
  * Called when this object is first created, to set the initial OpenGL state
  * required by this lab. Specify your render settings here.
  */
void ParticleWidget::initializeGL()
{
    glClearColor(0.0f,0.0f,0.0f,0.0f);

    //m_emitter = new ParticleEmitter(loadTexture("/Users/mjunck/Dev/cs123/cs123_final/lab06/textures"));
    //glDisable(GL_DITHER);
    //glDisable(GL_LIGHTING);

    //glEnable(GL_TEXTURE_2D);

    // Enable depth testing, so that objects are occluded based on depth instead of drawing order
    glEnable(GL_DEPTH_TEST);

    // Enable back-face culling, meaning only the front side of every face is rendered
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);

    // Specify that the front face is represented by vertices in counterclockwise order (this is the default)
    glFrontFace(GL_CCW);

    // Enable color materials with ambient and diffuse lighting terms
    glEnable(GL_COLOR_MATERIAL);
    glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);

    // Set up global (ambient) lighting
    GLfloat global_ambient[] = { 0.2f, 0.2f, 0.2f, 1.0f };
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, global_ambient);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 1);

    // Set up GL_LIGHT0 with a position and lighting properties
    GLfloat ambientLight[] = {0.1f, 0.1f, 0.1f, 1.0f};
    GLfloat diffuseLight[] = { 1.0f, 1.0f, 1.0, 1.0f };
    GLfloat specularLight[] = { 0.5f, 0.5f, 0.5f, 1.0f };
    GLfloat position[] = { 2.0f, 2.0f, 2.0f, 1.0f };
    glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuseLight);
    glLightfv(GL_LIGHT0, GL_SPECULAR, specularLight);
    glLightfv(GL_LIGHT0, GL_POSITION, position);

    // Set the screen color when the color buffer is cleared (in RGBA format)
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

    // Enable light 0
    glEnable(GL_LIGHT0);

    // Load the initial settings
    //updateSettings();

    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glEnable(GL_LIGHTING);
    glShadeModel(GL_SMOOTH);

    updateCamera();
    //emit _glInit(); //leave this

    glPushMatrix();
    glTranslatef(0.0, 0.0, 0.0);
    glColor3f(0.0, .75, .75);
    gluSphere(m_quadric, 10.0, 20, 20);

    glPopMatrix();
}

/**
  * You need to fill this in
  *
  * Called several times per second to draw your particlescene. This is where
  * all of your OpenGL render calls should occur.
  */
void ParticleWidget::paintGL()
{
    float time = m_increment++ / 20.0;

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //clear the color & depth buffers

    //m_emitter->updateParticles();       //Move the particles
    //m_emitter->drawParticles();         //Draw the particles


    //my stuff added in
//    for (int i = 0; i < NUM_EMITTERS; i++) {

//        Emitter *e = m_emitters[i];
//        e->addDrop();
//        e->updateDrops();
//        e->drawDroplets();
//    }

//    glPushMatrix();
//    glTranslatef(0.0, 0.0, 0.0);
//    glColor3f(0.0, .75, .75);
//    gluSphere(m_quadric, 10.0, 20, 20);

//    glPopMatrix();

    //end my stuff

    glFlush();
    swapBuffers();

    cout << "painting inc " << m_increment << endl;
}

/**
  * Resizes the viewport so the scene doesn't look distorted when the window is resized.
  * You should not need to modify this.
  */
void ParticleWidget::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
    updateCamera();
}

/**
  * Applied the current camera position and orientation to the OpenGL modelview and projection matrices.
  * You should not need to modify this.
  */
void ParticleWidget::updateCamera()
{
    float w = width(), h = height();
    float ratio = w / h;

    // Reset the coordinate system before modifying
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(m_camera->angle, ratio, m_camera->near, m_camera->far);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(m_camera->eye.x, m_camera->eye.y, m_camera->eye.z,
              m_camera->center.x, m_camera->center.y, m_camera->center.z,
              m_camera->up.x, m_camera->up.y, m_camera->up.z);
}

void ParticleWidget::redraw() { update(); }
